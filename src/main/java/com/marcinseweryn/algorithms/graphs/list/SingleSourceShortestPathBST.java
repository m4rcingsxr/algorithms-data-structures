package com.marcinseweryn.algorithms.graphs.list;

import com.marcinseweryn.algorithms.datastructures.queue.LinkedListQueue;
import com.marcinseweryn.algorithms.datastructures.queue.Queue;

import java.util.*;

/**
 * This class provides methods to find the shortest path between two vertices
 * in an unweighted graph using the Breadth-First Search (BFS) algorithm. BFS
 * is ideal for finding the shortest path in unweighted graphs as it explores
 * vertices level by level, ensuring the shortest path is found.
 *
 * <h2>Breadth-First Search (BFS):</h2>
 * <p>
 * BFS is a traversal algorithm that starts from a given vertex and explores
 * all its neighbors before moving to the next level of neighbors. It uses
 * a queue to keep track of the vertices to be explored. When applied to
 * an unweighted graph, BFS ensures that the first time a vertex is reached,
 * it is via the shortest path.
 * </p>
 *
 * <h2>Complexity Analysis:</h2>
 * <h3>Time Complexity:</h3>
 * <p>
 * The time complexity of BFS is O(V + E), where V is the number of vertices
 * and E is the number of edges. This is because each vertex and edge is
 * processed at most once.
 * </p>
 *
 * <h3>Space Complexity:</h3>
 * <p>
 * The space complexity of BFS is O(V), due to the storage of the visited
 * array, parent array, and queue used for the BFS traversal.
 * </p>
 *
 * <h2>Graph Representation:</h2>
 * <p>
 * The graph is represented as an adjacency list, where each vertex has a
 * list of integers representing its neighbors. This representation is
 * efficient for sparse graphs and allows easy addition and removal of edges.
 * </p>
 *
 * <h2>Usage:</h2>
 * <p>
 * This class can be used to find the shortest path in an unweighted graph.
 * It supports:
 * <ul>
 *   <li>Finding the shortest path between two vertices using BFS.</li>
 * </ul>
 * </p>
 */
public class SingleSourceShortestPathBST {

    /**
     * Private constructor to prevent instantiation of the class.
     * This class contains only static methods.
     */
    private SingleSourceShortestPathBST() {
    }

    /**
     * Finds the shortest path between two vertices in a graph using a BFS
     * algorithm. This method is designed for unweighted graphs.
     *
     * @param graph the graph represented as a list of adjacency lists
     * @param start the index of the starting vertex
     * @param end   the index of the ending vertex
     * @return a list of integers representing the vertices in the shortest
     * path from start to end
     */
    public static List<Integer> shortestPath(
            List<List<Integer>> graph,
            int start, int end) {
        // Perform BFS from the start vertex to determine the parent of each vertex in the shortest path
        Integer[] path = bfs(graph, start);
        // Reconstruct the shortest path from the start vertex to the end vertex
        return constructPath(path, start, end);
    }

    /**
     * Reconstructs the shortest path from start to end based on the parent
     * array generated by the BFS algorithm. If the end vertex is unreachable
     * from the start vertex, returns an empty list.
     *
     * @param parent the parent array generated by the BFS algorithm
     * @param start  the index of the starting vertex
     * @param end    the index of the ending vertex
     * @return a list of integers representing the vertices in the shortest
     * path from start to end, or an empty list if no path exists
     */
    private static List<Integer> constructPath(Integer[] parent, int start, int end) {
        List<Integer> path = new ArrayList<>();
        // Backtrack from the end vertex using the parent array to reconstruct the path
        for (Integer i = end; i != null; i = parent[i]) {
            path.add(i);
        }

        // Reverse the path to get it in the correct order from start to end
        Collections.reverse(path);

        // If the start of the path is not the start vertex, no path exists
        if (path.get(0) != start) return Collections.emptyList();
        return path;
    }

    /**
     * Performs a BFS traversal of the graph starting from the current vertex.
     * It calculates the shortest path from the start vertex to all other vertices
     * in an unweighted graph by using a queue to explore the nearest vertices first.
     *
     * @param graph   the graph represented as a list of adjacency lists
     * @param current the index of the current vertex
     * @return an array representing the parent of each vertex in the BFS traversal
     */
    private static Integer[] bfs(List<List<Integer>> graph, Integer current) {
        Integer[] path = new Integer[graph.size()]; // Array to store the parent of each vertex
        boolean[] visited = new boolean[graph.size()]; // Array to track visited vertices

        Queue<Integer> queue = new LinkedListQueue<>(); // Queue for BFS
        queue.enqueue(current); // Start BFS from the current vertex
        visited[current] = true; // Mark the start vertex as visited

        // Perform BFS traversal
        while (!queue.isEmpty()) {
            current = queue.dequeue(); // Dequeue the next vertex to explore

            List<Integer> neighbors = graph.get(current); // Get neighbors of the current vertex
            for (Integer neighbor : neighbors) {
                if (!visited[neighbor]) { // If the neighbor has not been visited
                    visited[neighbor] = true; // Mark it as visited
                    queue.enqueue(neighbor); // Enqueue it for exploration
                    path[neighbor] = current; // Set the current vertex as its parent
                }
            }
        }

        return path; // Return the parent array for path reconstruction
    }

    /**
     * Creates an empty graph represented as a list of adjacency lists with
     * the specified number of vertices. Each vertex is initialized with an empty
     * adjacency list.
     *
     * @param noVertices the number of vertices in the graph
     * @return an empty graph represented as a list of adjacency lists
     */
    public static List<List<Integer>> createGraph(int noVertices) {
        List<List<Integer>> graph = new ArrayList<>();
        for (int i = 0; i < noVertices; i++) {
            graph.add(new ArrayList<>()); // Initialize each vertex's adjacency list as empty
        }
        return graph;
    }

    /**
     * Adds an undirected edge between two vertices in the graph. This method
     * updates the adjacency lists of both vertices to include each other.
     *
     * @param graph the graph represented as a list of lists of integers
     * @param from  the starting vertex
     * @param to    the ending vertex
     */
    public static void addUndirectedEdge(List<List<Integer>> graph, int from, int to) {
        addDirectedEdge(graph, from, to); // Add edge from 'from' to 'to'
        addDirectedEdge(graph, to, from); // Add edge from 'to' to 'from'
    }

    /**
     * Adds a directed edge from one vertex to another by updating the adjacency list
     * of the 'from' vertex to include the 'to' vertex.
     *
     * @param graph the graph represented as a list of lists of integers
     * @param from  the starting vertex
     * @param to    the ending vertex
     */
    public static void addDirectedEdge(List<List<Integer>> graph, int from, int to) {
        graph.get(from).add(to); // Add the edge to the adjacency list of the 'from' vertex
    }

    public static void main(String[] args) {

        // Graph structure:
        //                 1     12
        //               /   \ /   \
        //             10     8     2   4
        //               \   /       \ /
        //                9          3       5
        //                  \       /       /
        //                   0  -- 7  -- 6
        //                    \
        //                      11
        List<List<Integer>> graph = createGraph(13);
        addUndirectedEdge(graph, 0, 7);
        addUndirectedEdge(graph, 0, 9);
        addUndirectedEdge(graph, 0, 11);
        addUndirectedEdge(graph, 7, 6);
        addUndirectedEdge(graph, 7, 3);
        addUndirectedEdge(graph, 6, 5);
        addUndirectedEdge(graph, 3, 4);
        addUndirectedEdge(graph, 2, 3);
        addUndirectedEdge(graph, 2, 12);
        addUndirectedEdge(graph, 12, 8);
        addUndirectedEdge(graph, 8, 1);
        addUndirectedEdge(graph, 1, 10);
        addUndirectedEdge(graph, 10, 9);
        addUndirectedEdge(graph, 9, 8);

        // Expected output: [0, 9, 8, 12] which is the shortest path from node 0 to node 12
        System.out.println(shortestPath(graph, 0, 12));
    }

}
