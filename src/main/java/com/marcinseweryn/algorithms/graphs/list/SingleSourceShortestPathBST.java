package com.marcinseweryn.algorithms.graphs.list;

import java.util.*;

/**
 * This class provides methods for finding the shortest path between two
 * vertices in a graph using a Breadth-First Search (BFS) algorithm.
 */
public class SingleSourceShortestPathBST {

    /**
     * Private constructor to prevent instantiation of the class.
     */
    private SingleSourceShortestPathBST() {
    }

    /**
     * Finds the shortest path between two vertices in a graph using a BFS
     * algorithm.
     *
     * @param graph the graph represented as a list of adjacency lists
     * @param start the index of the starting vertex
     * @param end   the index of the ending vertex
     * @return a list of integers representing the vertices in the shortest
     * path from start to end
     */
    public static List<Integer> ssspTwoVertices(
            List<List<Integer>> graph,
            int start, int end) {
        Integer[] parent = bfs(graph, start);
        return reconstructPath(parent, start, end);
    }

    /**
     * Reconstructs the shortest path from start to end based on the parent
     * array generated by the BFS algorithm.
     *
     * @param parent the parent array generated by the BFS algorithm
     * @param start  the index of the starting vertex
     * @param end    the index of the ending vertex
     * @return a list of integers representing the vertices in the shortest
     * path from start to end
     */
    private static List<Integer> reconstructPath(Integer[] parent, int start,
                                                 int end) {
        List<Integer> path = new ArrayList<>();
        System.out.println(Arrays.toString(parent));

        // Iterate backward to get parent for each vertex
        // and fill path list from backward
        // current = null if vertex has no parent
        for (Integer i = end; i != null; i = parent[i]) {
            path.add(i);
        }
        Collections.reverse(path);

        // If backward iteration result compute other
        // result it means that vertices are not connected
        if (path.get(0) != start) {
            path.clear();
        }
        return path;
    }

    /**
     * Performs a BFS traversal of the graph starting from the current vertex.
     *
     * @param graph   the graph represented as a list of adjacency lists
     * @param current the index of the current vertex
     * @return an array representing the parent of each vertex in the BFS
     * traversal
     */
    private static Integer[] bfs(List<List<Integer>> graph, int current) {
        int N = graph.size();
        Integer[] parent = new Integer[N];
        boolean[] visited = new boolean[N];
        Queue<Integer> queue = new ArrayDeque<>();
        queue.add(current);
        visited[current] = true;

        while (!queue.isEmpty()) {
            current = queue.remove();

            for (Integer neighbor : graph.get(current)) {
                if (!visited[neighbor]) {
                    queue.add(neighbor);
                    visited[neighbor] = true;
                    parent[neighbor] = current;
                }
            }
        }
        return parent;
    }

    /**
     * Creates an empty graph represented as a list of adjacency lists with
     * the specified number of vertices.
     *
     * @param noVertices the number of vertices in the graph
     * @return an empty graph represented as a list of adjacency lists
     */
    public static List<List<Integer>> createGraph(int noVertices) {
        List<List<Integer>> graph = new ArrayList<>();
        for (int i = 0; i < noVertices; i++) {
            graph.add(new ArrayList<>());
        }
        return graph;
    }

    /**
     * Adds an undirected edge between two vertices in the graph.
     *
     * @param graph the graph represented as a list of lists of integers
     * @param from  the starting vertex
     * @param to    the ending vertex
     */
    public static void addUndirectedEdge(List<List<Integer>> graph, int from,
                                         int to) {
        graph.get(from).add(to);
        graph.get(to).add(from);
    }

    /**
     * Adds a directed edge from one vertex to another
     *
     * @param graph the graph represented as a list of lists of integers
     * @param from  the starting vertex
     * @param to    the ending vertex
     */
    public static void addDirectedEdge(List<List<Integer>> graph, int from,
                                       int to) {
        graph.get(from).add(to);
    }

    public static void main(String[] args) {

        //                 1     12
        //               /   \ /   \
        //             10     8     2   4
        //               \   /       \ /
        //                9          3       5
        //                  \       /       /
        //                   0  -- 7  -- 6
        //                    \
        //                      11
        List<List<Integer>> graph = createGraph(13);
        addUndirectedEdge(graph, 0, 7);
        addUndirectedEdge(graph, 0, 9);
        addUndirectedEdge(graph, 0, 11);
        addUndirectedEdge(graph, 7, 6);
        addUndirectedEdge(graph, 7, 3);
        addUndirectedEdge(graph, 6, 5);
        addUndirectedEdge(graph, 3, 4);
        addUndirectedEdge(graph, 2, 3);
        addUndirectedEdge(graph, 2, 12);
        addUndirectedEdge(graph, 12, 8);
        addUndirectedEdge(graph, 8, 1);
        addUndirectedEdge(graph, 1, 10);
        addUndirectedEdge(graph, 10, 9);
        addUndirectedEdge(graph, 9, 8);

        System.out.println(ssspTwoVertices(graph, 0, 2));
    }

}
